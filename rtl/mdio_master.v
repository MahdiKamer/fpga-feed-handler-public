// Mdio_master.v
// Simple Clause-22 MDIO master (bitbang)
// - Supports MDIO read and write operations
// - Inout mdio line implemented with tri-state
// - MDC generated by dividing fabric clock
// Notes: assumes fabric_clk and rst_sync (active-high) exist in top
`timescale 1ns/1ps
module mdio_master #(
    parameter integer MDC_DIV = 50  // Divide fabric_clk to produce MDC (125MHz/50 = 2.5 MHz)
) (
    input  wire         clk,        // Fabric clock (e.g. 125 MHz)
    input  wire         rst,        // Active-high synchronous reset

    // Command interface
    input  wire         cmd_valid,  // Pulse to start command (1 cycle)
    input  wire         cmd_read,   // 1 = read, 0 = write
    input  wire [4:0]   cmd_phyaddr,// PHY address
    input  wire [4:0]   cmd_regaddr,// Register address
    input  wire [15:0]  cmd_wdata,  // Data to write (for write)

    output reg          busy,       // 1 while operation in progress
    output reg          ack,        // 1 for one cycle when operation completes (success)
    output reg  [15:0]  rdata,      // Read data (valid when ack & cmd_read)

    // MDIO physical
    output reg          mdc,        // MDC (clock output)
    inout  wire         mdio        // MDIO (bidirectional)
);

    // -------------------------------------------------------------------
    // Internal: mdio tri-state driver
    // -------------------------------------------------------------------
    reg mdio_out_en;
    reg mdio_out; // Value driven onto mdio when mdio_out_en
    assign mdio = mdio_out_en ? mdio_out : 1'bz;

    // -------------------------------------------------------------------
    // MDC generator
    // -------------------------------------------------------------------
    reg [$clog2(MDC_DIV)-1:0] mdc_cnt;
    reg mdc_tick; // Single-cycle tick when MDC toggles

    always @(posedge clk) begin
        if (rst) begin
            mdc_cnt <= 0;
            mdc <= 1'b0;
            mdc_tick <= 1'b0;
        end else begin
            if (mdc_cnt == (MDC_DIV/2 - 1)) begin
                mdc_cnt <= 0;
                mdc <= ~mdc;
                mdc_tick <= 1'b1;
            end else begin
                mdc_cnt <= mdc_cnt + 1'b1;
                mdc_tick <= 1'b0;
            end
        end
    end

    // This will sample/drive MDIO synchronised to the rising edge of MDC (i.e., when mdc transitions 0-->1).
    // Simpler: produce a state machine that advances one bit per MDC full cycle (two mdc ticks) using a 'mdc_edge' pulse.
    reg mdc_prev;
    wire mdc_rising = (mdc == 1'b1 && mdc_prev == 1'b0);
    always @(posedge clk) mdc_prev <= mdc;

    // -------------------------------------------------------------------
    // MDIO frame building / shifting (Clause 22)
    // Frame (write):
    // Preamble: 32 x '1'
    // ST(2) = 01
    // OP(2) = 01 (write) or 10 (read)
    // PHYAD(5)
    // REGAD(5)
    // TA(2) = 10 (for write) or Z0 (for read)
    // DATA(16)
    // For read, after TA the slave drives data, we read 16 bits.
    // -------------------------------------------------------------------
    localparam S_IDLE      = 0;
    localparam S_PREAMBLE  = 1;
    localparam S_ST_OP     = 2;
    localparam S_TA        = 4;
    localparam S_DATA_RW   = 5;
    localparam S_DATA_RD   = 6;
    localparam S_DONE      = 7;

    reg [2:0] state;
    reg [5:0] bitcnt; // Up to 32 bits for preamble
    reg [31:0] shift; // Shift register for sending bits
    reg [15:0] read_shift;
    reg [4:0] tmp_phy, tmp_reg;
    reg tmp_op; // 0=write,1=read

    // Ack generation and busy flag
    always @(posedge clk) begin
        if (rst) begin
            state <= S_IDLE;
            busy <= 1'b0;
            ack <= 1'b0;
            mdio_out_en <= 1'b0;
            mdio_out <= 1'b1;
            rdata <= 16'h0000;
            shift <= 32'hFFFFFFFF;
            bitcnt <= 0;
            tmp_phy <= 0;
            tmp_reg <= 0;
            tmp_op <= 0;
            read_shift <= 0;
        end else begin
            ack <= 1'b0;
            if (state == S_IDLE) begin
                mdio_out_en <= 1'b0;
                mdio_out <= 1'b1;
                if (cmd_valid) begin
                    busy <= 1'b1;
                    tmp_phy <= cmd_phyaddr;
                    tmp_reg <= cmd_regaddr;
                    tmp_op  <= cmd_read;
                    // Prepare preamble (32 ones) then ST/OP/PHY/REG
                    bitcnt <= 32;
                    // We will build portions as we go; shift used to shift out bits MSB first
                    state <= S_PREAMBLE;
                end else busy <= 1'b0;
            end else begin
                // Proceed on MDIO MDC rising edge to shift bits
                if (mdc_rising) begin
                    case (state)
                        S_PREAMBLE: begin
                            // Drive '1' for 32 cycles
                            mdio_out_en <= 1'b1;
                            mdio_out <= 1'b1;
                            if (bitcnt == 1) begin
                                // Move to ST/OP stage: This shifts ST(01) + OP(01/10) + PHY(5)+REG(5)
                                // Assemble a 14-bit sequence: ST(2)+OP(2)+PHY(5)+REG(5) => total 14 bits
                                // This sends MSB first; builds as 14-bit word and shifts out MSB...LSB
                                // Build: [ST(2)=01][OP(2)][PHY(5)][REG(5)]
                                // Flatten to 14-bit: (01)<<(12) | OP<<(10) | PHY<<(5) | REG
                                shift[13:0] <= {2'b01, (tmp_op ? 2'b10 : 2'b01), tmp_phy, tmp_reg};
                                bitcnt <= 14;
                                state <= S_ST_OP;
                                // Keep mdio_out high until next cycle where we start shifting
                                mdio_out <= 1'b1;
                            end else begin
                                bitcnt <= bitcnt - 1'b1;
                            end
                        end

                        S_ST_OP: begin
                            // Shift out head of 'shift' MSB-first (shift[13] first)
                            mdio_out_en <= 1'b1;
                            mdio_out <= shift[13];
                            shift <= {shift[12:0], 1'b0};
                            if (bitcnt == 1) begin
                                // Move to TA stage
                                if (!tmp_op) begin
                                    // Write: TA = 10 (drive '1' then '0')
                                    shift[1:0] <= 2'b10;
                                    bitcnt <= 2;
                                    state <= S_TA;
                                end else begin
                                    // Read: TA = Z0 -> master drives 'z' for first TA bit, then sample 0.
                                    // Implement by turning mdio tri-state for one clock, then sample next zero (slave drives)
                                    mdio_out_en <= 1'b0; // Tri-state for first TA bit
                                    bitcnt <= 2;
                                    state <= S_TA;
                                end
                            end else begin
                                bitcnt <= bitcnt - 1'b1;
                            end
                        end

                        S_TA: begin
                            if (!tmp_op) begin
                                // Write: send two bits (we prepared shift[1:0])
                                mdio_out_en <= 1'b1;
                                mdio_out <= shift[1];
                                shift <= {shift[0],1'b0};
                                if (bitcnt == 1) begin
                                    // Move to data write
                                    // Load data to shift reg MSB-first
                                    shift[15:0] <= cmd_wdata;
                                    bitcnt <= 16;
                                    state <= S_DATA_RW;
                                end else bitcnt <= bitcnt - 1'b1;
                            end else begin
                                // Read: first TA bit already tri-stated. On next MDC rising we'll sample the slave's TA(LSB) (should be 0)
                                if (bitcnt == 2) begin
                                    // First TA bit (master tri-stated) - already tri-stated
                                    mdio_out_en <= 1'b0;
                                    bitcnt <= bitcnt - 1'b1;
                                end else begin
                                    // Second TA bit - slave should drive 0; then proceed to read data
                                    mdio_out_en <= 1'b0; // Still tri-stated to read
                                    bitcnt <= 16;
                                    read_shift <= 16'h0000;
                                    state <= S_DATA_RD;
                                end
                            end
                        end

                        S_DATA_RW: begin
                            // Writing data, MSB first: shift[15] -> mdio
                            mdio_out_en <= 1'b1;
                            mdio_out <= shift[15];
                            shift <= {shift[14:0],1'b0};
                            if (bitcnt == 1) begin
                                state <= S_DONE;
                            end else bitcnt <= bitcnt - 1'b1;
                        end

                        S_DATA_RD: begin
                            // Read 16 data bits from slave, sample mdio on each rising MDC
                            mdio_out_en <= 1'b0; // Tri-state
                            read_shift <= {read_shift[14:0], mdio}; // Sample MDIO
                            if (bitcnt == 1) begin
                                rdata <= {read_shift[14:0], mdio};
                                state <= S_DONE;
                            end else bitcnt <= bitcnt - 1'b1;
                        end

                        S_DONE: begin
                            busy <= 1'b0;
                            ack <= 1'b1;
                            // Leave mdio tri-stated at end
                            mdio_out_en <= 1'b0;
                            state <= S_IDLE;
                        end

                        default: state <= S_IDLE;
                    endcase
                end // Mdc rising
            end // State != IDLE
        end
    end

endmodule